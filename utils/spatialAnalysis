import { FeatureCollection, Geometry, Position } from 'geojson';
import type { MapLayer } from '../types';

const isPointInPolygon = (point: Position, vs: Position[]): boolean => {
  const x = point[0], y = point[1];
  let inside = false;
  for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
    const xi = vs[i][0], yi = vs[i][1];
    const xj = vs[j][0], yj = vs[j][1];
    const intersect =
      ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
};

const extractPoints = (geometry: Geometry): Position[] => {
  const points: Position[] = [];

  if (geometry.type === 'Point') {
    points.push(geometry.coordinates as Position);
  } else if (geometry.type === 'Polygon') {
    const poly = geometry.coordinates as Position[][];
    if (poly.length > 0) points.push(poly[0][0]);
  } else if (geometry.type === 'LineString') {
    const line = geometry.coordinates as Position[];
    if (line.length > 0) {
      points.push(line[0]);
      points.push(line[line.length - 1]);
    }
  } else if (geometry.type === 'MultiPoint') {
    points.push(...(geometry.coordinates as Position[]));
  } else if (geometry.type === 'GeometryCollection') {
    geometry.geometries.forEach(g => points.push(...extractPoints(g)));
  }

  return points;
};

export const checkIntersections = (newData: FeatureCollection, existingLayers: MapLayer[]): string[] => {
  const matchedLayers = new Set<string>();
  const testPoints: Position[] = [];

  newData.features.forEach(feature => {
    if (feature.geometry) testPoints.push(...extractPoints(feature.geometry));
  });

  if (testPoints.length === 0) return [];

  existingLayers.forEach(layer => {
    if (!layer.visible) return;

    let isInsideLayer = false;

    layer.data.features.forEach(feature => {
      if (isInsideLayer) return;
      if (!feature.geometry) return;

      if (feature.geometry.type === 'Polygon') {
        const ring = (feature.geometry.coordinates as Position[][])[0];
        if (testPoints.some(p => isPointInPolygon(p, ring))) {
          isInsideLayer = true;
        }
      } else if (feature.geometry.type === 'MultiPolygon') {
        (feature.geometry.coordinates as Position[][][]).forEach(poly => {
          const ring = poly[0];
          if (testPoints.some(p => isPointInPolygon(p, ring))) {
            isInsideLayer = true;
          }
        });
      }
    });

    if (isInsideLayer) matchedLayers.add(layer.name);
  });

  return Array.from(matchedLayers);
};

export const checkCoverage = (newPolygonData: FeatureCollection, existingLayers: MapLayer[]): string[] => {
  const coveredLayers = new Set<string>();
  const polygons: Position[][] = [];

  newPolygonData.features.forEach(feature => {
    if (!feature.geometry) return;
    if (feature.geometry.type === 'Polygon') {
      polygons.push((feature.geometry.coordinates as Position[][])[0]);
    } else if (feature.geometry.type === 'MultiPolygon') {
      (feature.geometry.coordinates as Position[][][]).forEach(poly => polygons.push(poly[0]));
    }
